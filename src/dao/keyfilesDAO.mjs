import pkg from 'bson';
const { ObjectId } = pkg;
import UsersDAO from "./usersDAO.mjs"

let keyfileDb
export default class KeyfilesDAO {
    /**
     * Establishes the connection to the database and creates a handle for the keyfiles collection
     * This is wrapped in a try/catch block in case there is a network error, or some other issue
     * @param {string} conn: connection uri to the DB
     */
    static async injectDB(conn) {
        if (keyfileDb) {
            return
        }
        try {
            topl = await conn.db(process.env.TOPL_NS)
            keyfileDb = await conn.db(process.env.TOPL_NS).collection("addresses")
            this.keyfileDb = keyfileDb //only for testing
        } catch (e) {
            console.error(
                `Unable to establish a collection handle in addressesDAO: ${e}`
            )
        }
    }

    /**
        * Retrieves the connection pool size, write concern, and user roles on the current client
        *
        * @returns {Promise<ConfigurationResult>} An object with configuration details. 
        * 
    */

    static async getConfiguration() {
        const roleInfo = await topl.command({connectionStatus: 1})
        const authInfo = roleInfo.authInfo.authenticatedUserRoles[0]
        const {poolSize, wtimeout} = keyfileDb.s.db.serverConfig.s.options
        let response = {
            poolSize,
            wtimeout,
            authInfo
        }
        return response
    }
    /**
     * Inserts a keyfile into the "keyfiles" collection with the following fields: 
     *    - "user_id": the email of the user who owns the keyfile
     *    - "keyfile": the data of the keyfile generated by BramblJS
     *    - "lastModifiedDate": the date when the keyfile was last modified
     * @param {string} address_id The id for the address corresponding to this keyfile
     * @param {string} email: email for the user
     * @param {Object} keyfile: keyfile generated by BramblJS
     * @param {string} password: password to decrypt the keyfile
     * @param {string} date: The date on which the keyfile was created
     * @returns {DAOResponse} Returns an object with either DB response, or "error"
     */
    static async addKeyfile(address_id, email, keyfile, password, date) {
        try {
            keyfile = keyfile || {}
            let insertResult = await keyfileDb.insertOne({
                address_id: address_id, 
                user_id: email,
                keyfile: keyfile,
                password: password,
                date: date
            })
            console.log("inserted _id", insertedResult.insertedId)
            
            // let's ensure that we can find the keyfile that we just inserted with the insertedId that we just received

            if (await keyfileDb.findOne({
                _id: ObjectId(insertResult.insertedId)
            })) {
                return {success: true}
            } else {
                console.error(`Insert Keyfile Unsuccessful`)
                return {error: `Insertion unsuccessful`}
            }
            
        } catch (e) {
            // return an error message stating we've tried to insert a duplicate key
            if(String(e).startsWith("MongoError: E11000 duplicate key error")) {
                return {error: "A keyfile with the given address already exists"}
            }
            console.error(`Error occurred while adding new keyfile, ${e}.`)
            return {error: e}
        }
    }
    /**
     * Updates a keyfile in the keyfiles collection. Queries for the keyfile based by both the _id field as well as the user_id field to doubly ensure the user has permission to edit this keyfile. 
     * @param {string} keyfileId: The _id of the keyfile to update. 
     * @param {string} email : The email of the user who owns this keyfile. 
     * @param {string} password : The password of the keyfile to be updated.
     * @param {string | Date} date: The date on which the keyfile was most recently updated. 
     * @returns {DAOResponse} Returns either a "success" or an "error" object
     */

    static async updateKeyfile(keyfileId, email, password, date) {
        try {
            const oldKeyfile = await keyfileDb.findOne({_id: keyfileId, user_id: email})
            if (oldKeyFile) {
                const updateKeyfileResult = await keyfileDb.updateOne(
                    {_id: keyfileId, user_id: email}, 
                    {
                        $set: {password: password},
                        $set: {lastModifiedDate: date}
                    }
                )
                return updateKeyfileResult
            } else {
                console.error('Update unsucccessful')
                return {error: `Update unsuccessful`}
            }
        } catch (e) {
            console.error(`Error occurred while updating keyfile, ${e}`)
            return {error: e}
        }
    }
    /**
     * Ensures the delete operation is limited so only the user can delete their own keyfiles, but not anyone else's keyfiles using both the keyfileId and the user's email to delete the proper keyfile
     * 
     * @param {*} keyfileId 
     * @param {*} email 
     */
    static async deleteKeyfile(keyfileId, email) {
        try {
            const deletedKeyfile = await keyfileDb.findOneAndDelete(
                {user_id: email, _id: keyfileId}
                )
            if (!(await this.getKeyfileByID(deletedKeyfile._id))) {
                return {success: true}
            } else {
                console.error('Deletion unsuccessful')
                return {error: `Deletion unsuccessful`}
            }
        } catch (e) {
            console.error(`Error occurred while deleting user, ${e}`)
            return {error: e}
        }
    }

    /**
     * Finds all the keyfiles for a given email
     * @param {string} email - The email of the desired user
     * @returns {Object | null} Returns either an array of keyfiles, or nothing
     */

    static async getKeyfiles(email) {
        let filter = email
        let result = await keyfileDb.findOne(
            {email: filter}
        )
        return result
    }

    /**
        * Finds and returns address keyfiles from one or more addresses. 
        * Returns a list of objects, each object represents a keyfile 
        * @param {string} address_id: The address
        * @returns {Promise<AddressResult>} A promise that will resolve to a list of AddressResults.
        * 
    */

    static async getKeyfileByAddress(address_id) {
        let cursor
        try {
                // Let's find a keyfile for a given address. Because we're using findOne, we'll get a single object back.
                let filter = address
                cursor = await keyfileDb.findOne({address_id: filter})
                let {address_id, keyfile } = result
                console.log(result) 
        } catch (e) {
            console.error(`Unable to issue find command, ${e}`)
            return []
        }
        return cursor
    }
    /**
     * Gets a keyfile by its id
     * @param {string} id - The desired keyfile id, the _id in mongodb
     * @returns {KeyfileResult | null} Returns either a single Keyfile or nothing 
     */

    static async getKeyfileByID(id) {
        try {
            /** 
             * Given a keyfile id, retrieve the keyfile for that id.
            */
        const pipeline = [
            {
                $match: {
                    _id: ObjectId(id)
                }
            }
        ] 
        return await keyfileDb(pipeline).next()
    } catch (e) {
        console.error(`Something went wrong in getKeyfileByID: ${e}`)
        throw e
    }
}


/** 
 * Represents a single keyfile result
 * @typedef KeyfileResult
 * @property {string} _id
 * @property {string} address - The address of the keyfile
 * @property {ToplCrypto} crypto - The cryptographical elements of the keyfile
*/

/** 
 * The cryptographical elements from a keyfile
 * @typedef ToplCrypto
 * @property {string} mac: used to ensure correct decryption of cipher text, fails when supplied password is wrong
 * @property {string} kdf: the function used to derive a key for encrypting/decrypting the ciphertext
 * @property {string} cipherText: a 64 byte encrypted, byte-wise concatenation of the Curve25519 keypair (private key + public key)
 * @property {string} kdfSalt: a randomization value used in the key derivation function
 * @property {string} cipher: The encryption scheme used to generate the cipherText
 * @property {CipherParams} cipherParams: Parameters used by the encryption scheme
*/

/** 
 * cipher parameters
 * @typedef CipherParams
 * @property {string} iv: a set of bytes used in the encryption scheme to obfuscate the output
*/

/** 
 * Success/Error return object
 * @typedef DAOResponse
 * @property {boolean} [success] - Success
 * @property {string} [error] - Error
*/



    

    

}